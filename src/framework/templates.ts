/*
 Used for proper type implementation (currently not working tho)

 type SomeRequired<T, K extends keyof T> = T & Required<Pick<T, K>>;

type MergedInterfaces<B extends {}, S extends {}> = {
  [P in Exclude<keyof B, keyof S>]: B[P]
} & {
  [P in Exclude<keyof S, keyof B>]: S[P]
} & {
  [P in (keyof S) & (keyof B)]: Merged<B[P], S[P]>
};

// eslint-disable-next-line @typescript-eslint/no-empty-interface
type Interface = {
  [key: string]: any;
  [key: number]: any;
};

type Merged<B, S> =
  B extends Interface ? (S extends Interface ? MergedInterfaces<B, S> : S) : S;

type ReplaceNever<T, R = any> =
  T extends Interface ? { [P in keyof T]: ReplaceNever<T[P], R> } : (
    T extends never ? R : T
  );

type T = ReplaceNever<{ a: never; b: number }, string>; */

export type ServerlessProviderName = "aws";

export interface InlineFrameworkTemplate {
  // framework template cannot have the service name specified
  service?: {
    name?: never;
    [key: string]: unknown;
  };

  provider: {
    // framework requires a provider and region used for all services by default
    // note that provider name cannot be overwritten by service templates
    name: ServerlessProviderName; // currently only aws is supported
    region: string;

    stage?: never; // cannot set stage in template
    stackName?: never; // cannot be used, since services cannot share a stack name

    [key: string]: unknown;
  };

  custom?: {
    imports?: never;

    [key: string]: unknown;
  };

  resources?: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
}

export interface InlineServiceTemplate {
  service?: {
    name?: never; // is generated by framework
    [key: string]: unknown;
  };

  provider?: {
    name?: never; // cannot overwrite framework setting
    region?: string; // may overwrite framework region

    stage?: never; // cannot set stage in template
    stackName?: never; // cannot set stack name

    [key: string]: any;
  };

  custom?: {
    imports?: never;

    [key: string]: unknown;
  };

  resources?: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
}

// TEMPLATE PROCESSING
// TODO: properly refactor interfaces to actually transform the previous one

// INPUT

export type PreCompilationServerlessTemplate = {};

// STEP 1

export type ServerlessTemplatePreMerging = PreCompilationServerlessTemplate;

export type ServerlessTemplatePostMerging = {
  service?: {
    name?: never;
    [key: string]: unknown;
  };

  custom?: {
    imports?: never;

    [key: string]: unknown;
  };

  provider: {
    name: ServerlessProviderName;
    region: string;

    stage?: never;
    stackName?: never;

    [key: string]: unknown;
  };

  resources?: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
};

// STEP 2

export type ServerlessTemplatePrePreparation = ServerlessTemplatePostMerging;

export type ServerlessTemplatePostPreparation = {
  service: {
    name?: never;
    [key: string]: unknown;
  };

  custom: {
    imports?: never;

    [key: string]: unknown;
  };

  provider: {
    name: ServerlessProviderName;
    region: string;

    stage?: never;
    stackName?: never;

    [key: string]: unknown;
  };

  resources: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
};

// STEP 3

export type ServerlessTemplatePreNaming = ServerlessTemplatePostPreparation;

export type ServerlessTemplatePostNaming = {
  service: {
    name: string;
    [key: string]: unknown;
  };

  custom: {
    imports?: never;

    [key: string]: unknown;
  };

  provider: {
    name: ServerlessProviderName;
    region: string;

    stage: string;
    stackName: string;

    [key: string]: unknown;
  };

  resources: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
};

// STEP 4

export type ServerlessTemplatePreImports = ServerlessTemplatePostNaming;

export type ServerlessTemplatePostImports = {
  service: {
    name: string;
    [key: string]: unknown;
  };

  custom: {
    imports: Record<string, unknown>;

    [key: string]: unknown;
  };

  provider: {
    name: ServerlessProviderName;
    region: string;

    stage: string;
    stackName: string;

    [key: string]: unknown;
  };

  resources: {
    [key: string]: unknown;
  };

  [key: string]: unknown;
};

// STEP 5

export type ServerlessTemplatePreExports = ServerlessTemplatePostImports;

export type ServerlessTemplatePostExports = {
  service: {
    name: string;
    [key: string]: unknown;
  };

  custom: {
    imports: Record<string, unknown>;

    [key: string]: unknown;
  };

  provider: {
    name: ServerlessProviderName;
    region: string;

    stage: string;
    stackName: string;

    [key: string]: unknown;
  };

  [key: string]: unknown;
};

// OUTPUT

export type PostCompilationServerlessTemplate = ServerlessTemplatePostExports;

export type ServerlessTemplate = PostCompilationServerlessTemplate;
